# 알고리즘의 시간 복잡도

1. 초시계
  - 실제로 시간을 쟤는 것은 컴퓨팅 파워에 따라서 다르게 나타난다는 문제점이 있음
2. 연산횟수
  - 기본연산의 횟수를 구하는 것은 환경에 영향을 받지 않는 객관적인 방법, but 입력값에 따라 다르게 나올 수 있다는 문제성이 있음
    - 한 번 연산은 1시간
  - 따라서 성능을 측정할 때는 **입력을 통일** 시킴.
    - 가장 기본연산이 많이 일어나는 최악의 입력 n개가 들어온다고 가정 <- 시간 복잡도(Time Complextiy)
      - ex) 2n + 4 시간 : 입력에 n개를 넣을 쓸 때 2n + 4시간이 나온다.
3. 최악 n개
4. 빅오표기법(증가율)

### 시간 복잡도(Time Complexity)
- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킴
- 단순하게 알고리즘의 수행시간을 의미
  - 시간 복잡도가 높다 -> 느린 알고리즘
  - 시간 복잡도가 낮다 -> 빠른 알고리즘
- n개 기준으로 하기 떄문에 증가율이 중요함
- https://wiki.python.org/moin/TimeComplexity

### Big-O (빅오) 표기법
- 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것
- 최고차항만 남기고 계수와 상수 제거
- ex)
  - 3n + 1 -> O(n)
  - 6n + 9 -> O(n)
  - 2n^2 + 9n +1 -> O(n^2)
  - 7 -> O(7)
- 실제 문제에서 적용법
  - 보통 1초에 1억번 연산으로 가정
  - ex)
    - 입력 : 1 <= N <= 10억, 시간제한 1초
    - N을 다 더하는 경우
    - 다 더하면 시간초과
    - 가우스의 합 공식을 이용하면 4만에 구할 수 있음
      - reuturn (n * n+1) // 2
    - for for -> O(n ** 2)
    - max min sum count index find ... -> O(n)
    - for max -> O(n ** 2)
    - list in연산자 O(n)
    - set in연산자 0(1) <- 해시 테이블로 구현되어 있기 때문에
    - dict in연산자 0(1) <- 해시 테이블로 구현되어 있기 때문에