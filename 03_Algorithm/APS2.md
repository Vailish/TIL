# APS 응용
- APS(Algorithm Problem Solving) 응용

- SW 문제 해결
- 복잡도 분석
- 표준 입출력 방법
- 비트 연산
- 진수
- 실수

### 복잡도 분석
#### 알고리즘
- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**
- 공간적 효율성과 시간적 효율성
  - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간, 시간적 효율성 : 연산량 대비 얼마나 적은 시간
- 시간적 복잡도 분석 : 상황에 따라 변해서 어렵다

#### 복잡도의 점근적 표기
- Big-Oh
- Big-Omega
- Big-theta

- O(Big-oh)표기
  - 복잡도의 점근적 상한
  - 최악의 경우에도 이것보다 적을 것이다
- Big-Omega 표기
  - 복잡도의 점근적 하한
  - 최소한 이만한 시간은 걸린다
- Theta표기
  - Big-oh와 Big-Omega와 같을 때

### 표준 입출력 방법
#### python3 표준입출력
- 입력
  - Raw 값의 입력 : input() <- 받은 입력값을 문자열로 취급
  - Evaluated된 값 입력 : eval(input()) <- 받은 입력값을 평가된 데이터 형으로 취급
- 출력
  - print() : 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
  - print('text', end='') : 출력 시 마지막에 개행문자 제외할 시
  - print('%d' % number) : Formatting된 출력
- 파일의 내용을 표준 입력으로 읽어오는 방법
  - import sys
  - sys.stdin = open('a.txt', 'r')

### 비트 연산
#### 비트 연산자
- & : 비트단위로 AND 연산을 한다. ex) num1 & num2
  - bit & 0 -> 무조건 0 / bit & 1 -> 원래 bit 그대로 / 특정비트를 0으로 만들때 (1 & 0)
- | : 비트단위로 OR 연산을 한다. ex) num1 | num2
- ^ : 비트 단위로 XOR 연산을 한다.(같으면 0, 다르면 1) ex) num1 ^ num2
- ~ : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. ex) ~num
- << : 피연산자의 비트 열을 왼쪽으로 이동시킨다. ex) num << 2 (shift라고 읽음)
  - ex) [0,0,0,1,0,0,1,0] << 2 : [0,1,0,0,1,0,0,0,]
- >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다. ex) num >> 2

- 1 << n
  - 2 ** n의 값을 갖음
  - 원소가 n개일 경우 모든 부분집합의 수를 의미함
  - Power set(모든 부분 집합)
    - 공집합과 자기 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산됨
- i & (1<<j))
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다.
  - i의 j번 비트검사
    - ex) i =  [0, 1, 1, 0] 2번 비트검사 : i &(1<<2)

#### 엔디안(Endianness)
- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다.
- 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때 올바로 이해하지 않으면 오류를 발생 시킬 수 있다.
- 엔디안
  - Big-endian : 보통 큰 단위가 앞에 나옴. 네트워크
  - Little-endian : 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터
- 0x1234의 표현 / 0x12345678의 표현
  - 빅 엔디안 12 34 / 12 34 56 78
  - 리틀 엔디안 34 12 / 78 56 34 12
  - ex) 확인방법
```python
import sys
print(sys.byteorder)  # little
```

### 진수
#### 컴퓨터에서의 음의 정수 표현 방법
- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들로 0은 1로, 1은 0로 변환함
- -6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 : 부호와 절대값 표현
- -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 : 1의 보수 표현
  - 각 자리수에서 뺸 값
- 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
- -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 : 2의 보수 표현
- 보통 2의 보수를 사용한다. 계산도 간단하고 0도 하나고해서 좋음

### 실수
- 부동소수점
- 실수를 저장하기 위한 형식
  - 단정도 실수(32bit) : 부호 1bit + 지수 8bit + 가수 23bit
  - 배정도 실수(64bit) : 부호 1bit + 지수 11bit + 가수 52bit
  - 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
  - 지수부(exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것