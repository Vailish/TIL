### 제어문
- 제어문
    - 조건문 
    - 반복문
- 파이썬은 기본적으로 위에서 아래로 차례로 명령 수행
- 코드를 선택적으로 실행(분기/조건)하거나 계속하여 실행(반복)하는 제어가 필요함
- 순서도(flowchart)로 표현가능

##### 복수 조건문
- 참/거짓을 판단할 수 있는 조건식
- 형식
  ```python
  if a > 5:
      print('5 초과')
  else:
      print('5 이하')
  print(a)
  ```

##### 복수 조건문
- 동시에가 아니라 하나씩 검사함.
- if 아래에 elif 넣어주면됨.

##### 중첩 조건문
- 조건문에 조건문 중첩
- 형식(들여쓰기 조심)
  ```python
  if 조건:
      #code block
      if 조건:
          #code block
  ```

##### 조건 표현식
- 삼항 연산자(Ternary Operator)로 부르기도 함
- 형식
    - true인 경우 값 if 조건 else false인 경우 값
    - 왼참 if 조건 else 오거
    - ex)
     ```python
    value = num if num >= 0 else -num #절대값을 저장하기 위한 코드
    ```

### 반복문
- 특정 조건을 만족할때까지 같은 동작을 계속 반복하고 싶을 때 사용
- while 문 : 종료조건에 해당하는 코드를 통해 반복문을 종료 시켜야함
- for 문 : 반복가능한 객체를 모두 순회하면 종료 (별도의 종료조건이 필요없음)
- 반복제어 : break, continue, for-else

##### while문
- 조건식이 참인 경우 반복적으로 코드를 실행
- 무한 루프를 하지 않도록 **종료조건**이 반드시 필요
- 형식
  
  ```python
  while 조건:
    #code block
  ```

##### 복합연산자(In-place Operator)
- 연산과 할당을 합쳐 놓은 것
- ex) 반복문을 통해서 개수를 카운트 하는 경우
  ```python
  a = 0
  while a < 5:
    print(a)
    a += 1
  print('끝')
  ```

##### For문
- 시퀀스(string, tuple, list, range)를 포함한 순회 가능한 객체(iterable,반복가능한)의 요소를 모두 순회
    - 처음부터 끝까지 모두 순회하므로 별도의 종료 조건이 필요하지 않음
- Iterable
    - 순회할 수 있는 자료형(string, list, dict, tuple, range, set 등)
    - 순회형 함수(range, enumerate)
- 형식
    - for 변수명 in literable:
          #code block

###### 문자열(String) 순회
- 형식 1.
    ```python
    for char in chars:
        print(char)
    ```
- 형식 2.
    ```python
    for idx in range(len(chars)):
    print(chars[idx])
    ```

###### 딕셔너리(Dictionary) 순회
- 기본적으로 Key를 순회(key값을 뱉음), Key를 통해 값을 활용
- ex1)
```python
grade = {'john' : 80, 'eric' : 90}
for student in grades:
    print(student)
#john
#eric
```
- ex2)
```python
grade = {'john' : 80, 'eric' : 90}
for student in grades:
    print(student, grades[student])
#john 80
#eric 90
```
- 추가 매서드를 활용한 딕셔너리 순회
  - key() : key로 구성된 결과
  - values() : value로 구성된 결과
  - items() : (key, value)의 튜플로 구성된 결과
  - ex)
    ```python
    grades = {'john' : 80, 'eric' : 90}
    print(grades.keys())
    print(grades.values())
    print(grades.items())
    '''
    dict_keys {['john',]}
    dict_values {[80, 90]}
    dict_items {[('john', 80), ('eric', 90)]}
    '''
    for student, grade in grades.items():
        print(student, grade)
    '''
    john 80
    eric 90
    '''
    ```
    - dictionary는 append가 없는 대신에
    - a['a'] = b <- 이런식으로 만들어 줄 수 있음

##### enumerate 순회
- enumerate()
  - 인덱스와 객체를 쌍으로 담은 열거형(enumerate) 객체 반환
    - (index, value) 형태의 tuple로 구성된 열거 객체 반환
- ex1)
```python
members = ['민수', '영희', '철수']
for idx, number in enumerate(members):
    print(idx, number)
'''
0 민수
1 영희
2 철수
'''
```
- ex2)
```python
members = ['민수', '영희', '철수']
enumerate(members) # enumerate at 0x105d3e100
print(list(enumerate(members))) # [(0, '민수'), (1, '영희'), (2, '철수')]
print(list(enumerate(members, start=1))) # [(1, '민수'), (2, '영희'), (3, '철수')]
#start=n n부터 시작
```

###### List Comprehension
- 표현식과 제어문을 통해 특정한 값을 가진 리스트를 간결하게 생성하는 방법
- 알고리즘할 때 많이 쓰임!
- 형식
  [code for 변수 in iterable]
  [code for 변수 in iterable if 조건식]
- ex)
```python
cubic_list = []
for number in range(1, 4):
    cubic_list.append(number ** 3)
print(cubic_list)
#[1, 8, 27]

cubic_list = [number ** 3 for number in range(1, 4)]
print(cubic_list)
#[1, 8, 27]

a = []
for i in range(5):
    a.append(i)
print(a)
#[0, 1, 2, 3, 4]

a = [a for i in range(5) if a % 2 == 1]
#흠... 다시해보자
```

###### Dictionary Comprehension
- 표현식과 제어문을 통해 특정한 값을 가진 딕셔너리를 간결하게 생성하는 방법
- 형식
  - {key : value for 변수 in iterable} 
  - {key : value for 변수 in iterable if 조건식} 
- ex)
```python
cubic_dict = {}

for number in range(1, 4):
    cubic_dict[number] = number ** 3
print(cubic_dict)
# {1: 1, 2: 8, 3: 27}

cubic_dict = {number: number ** 3 for number in range(1, 4)}
print(cubic_dict)
# {1: 1, 2: 8, 3: 27}
```

##### 반복문 제어
- break <- 파토
  - 반복문을 종료
```python
n = 0
while True :
    if n == 3:
        break
    print(n)
    n += 1
```
- continue <- 지나가유~
  - continue 이후 코드 블록은 수행하지 않고, 다음 반복을 수행
    - 다음번꺼 넣음 ex) range(5) 인데 1수행시 continue를 만나면, 1은 이후 스킵, 2를 넣어서 실행
    - ex)
```python
a = 0
while a < 5:
    if a == 3:
        continue
    print(a)
    a += 1
#이런식으로 쓰는데 이 코드에서는 3에서 무한루프가 됨. 여튼 3을 피하고싶다 이럴때 쓰면 됨
```
- for-else
  - 끝까지 반복문을 실행한 이후에 else문 실행
  - break를 통해 중간에 종료되는 경우 else문은 실행되지 않음(break는 if문 자체를 끝내버림), 끝까지 돌았으면 else 출력.
  - ex)
```python
for a in range(5):
    print(a)
    if a == 3:
        break
else:
    print("모두 다 돌았습니다.")
'''
0
1
2
3
'''
```
 
- pass
  - 아무것도 하지 않음(문법적으로 필요하지만, 할 일이 없을 때 사용)
  - 반복문 아니어도 사용 가능
  - ex)

### 함수
- 함수를 쓰는 이유
  - Decomposition(분해)
    - 기능 단위로 쪼개서(분해해서) 재사용하기 편하게 사용!
    - 간결하고, 이해하기 쉽다!
  - Abstraction(추상화)
    - 복잡한 내용은 모르더라도 사용할 수 있도록(ex) 스마트폰 원리는 몰라도 잘씀)
    - 재사용성과 가독성, 생산성
  - 함수 = 미니프로그램, 프로그램이 갖는 저장과 처리 둘다 갖고있다.
    - 프로그램 : input(input()) -> .py(프로그램) -> output(print())
    - 함수 : input(파라미터) ->  -> output(return)
      - 함수를 사용할때 실제 입력값 Argument
        - ex) def function(**ham**) : ham parameter
      - 함수를 선언할때 입력값 parameter -> 함수 안에서만 사용가능]
        - ex) function(**'spam'**) : 'spam' argument



- len([1, 2, 3])
- sum([1, 2, 3])
- input() -> 문자열로 받는다, 한 줄로 받는다.
- range(시작점, 끝점-1 , *간격*)


##### 함수 기초
- 함수의 종류
  - 내장 함수 <-파이썬 개발자가 만듦
    - 파이썬에 기본적으로 포함된 함수(설치X) <-버전마다 바뀔 수 있음
  - 외장함수 <- 다른 개발자
    - import 문을 통해 사용하며, 외부 라이브러리에서 제공하는 함수
  - 사용자 정의 함수
    - 직접 사용자가 만드는 함수
- 함수의 정의
  - 특정한 기능을 하는 코드의 조각(묶음) 
- 함수의 기본 구조
  - 선언과 호출(생성, 사용 define & call)
  - 입력(Input) <- 재료
  - 문서화(Docstring) <- 함수에대한 주석, 설명
  - 범위(Scope)
  - 결과값(Output) <- 레시피, 함수 식, return

###### 선언과 로출
- def키워드로 선언
- Fuction body(실행될 코드 블록) 작성
  - Docstring은 함수 body 앞에 선택적 작성 가능 <- 설명서쓸지 여부결정
    - 작성 시에는 반드시 첫 번째 문장에 문자열 ''''''
- 함수는 parameter를 넘겨줄 수 있음 <- print **()** <- 이게 파라미터
- 함수는 동작 후에 return을 통해 결과값 전달

##### 함수의 결과값(Output)
- void function
  - 명시적인 return 값이 없는 경우, None(다른곳에서는 void라고함)을 반환하고 종료 : 반환값이 없는 함수 =  None, void
  - ex) print <- 정확히 말하면 return None이 생략되어 있는 것. 그래서 void 함수를 print하게되면 None을 반환함
- value returning fuction
  - 함수 실행 후, return문을 통해 값 반환
  - return을 하게되면(return을 만나는 순간, 아래는 실행 안됨), 값 반환 후 함수 바로 종료
- print 함수와 return의 차이점
  - print를 사용하면 호출될 때마다 값이 출력됨(주로 테스트를 위해 사용), 반환X = 결과가 없다
  - 데이터 처리를 위해서는 return 사용
  - REPL(Read-Eval-Print Loop) 환경(jupyter notebook)에서는 작성된 코드 리턴값을 보여주므로 같은 걸로 착각할 수 있다.
- 두 개 이상의 값 반환
  - return은 한 개만 반환함
  - return x - y, x * y -> 이런식으로 튜플로 묶어서 반환하는 방법이 있다.

##### 함수의 입력(Input)
- Parameter : 함수 정의시 함수 내부에서 사용되는 변수
  - 
- Argument : 함수 호출시 넣어주는 값
  - 필수 Argument : 반드시 전달되어야하는 Argument
  - 선택 Argument : 값을 전달하지 않아도 되는 경우는 기본값 전달
- Positional Arguments : 기본적으로 함수 호출 시 Argument는 위치에 따라 함수 내에 전달됨 - 특별한 사항이 없으면 이게 default값
  - def add(x, y) -> add(x, y) : 순서대로
  - ex)
    ```python
    def add(x, y):
    return x + y

    add(x=2, y=5) #<- keyword argument 자리 바껴도 상관없음
    add(2, y=5) #<- 인자랑 키워드 인자랑 같이 쓸 수 있지만 같이 쓸 경우에는 무조건 인자부터 넣고 키워드 인자를 써야함.
    add(x=2, 5) #<-이건 오류남, 새치기하는 순간 순서가 망가져서 지정은 뒤에부터(앞에서 하려면 전부다 지정)
    ```
- Default Arguments Values
  - 기본값을 지정하여 함수 호출 시 argument 값을 설정하지 않도록 함
    - 정의된 것 보다 더 적은 개수의 argument들로 호출될 수 있음.
  - ex) def add(x, **y=0**) -> add(2)로 하더라도 자동으로 add(x, y=0)으로 넣음
- 정해지지 않은 여러개의 Arguments
  - 애스터리스크(Asterisk) 혹은 언패킹 연산자라고 불리는 *덕분
- 가변인자(*args)
  - 여러 개의 Positional Argument를 하나의 필수 parameter로 받아서 사용
  - 몇 개의 Positional Argument를 받을지 모르는 함수를 정의할 때 유용
    - ex)
```python
def add(*args):
  for arg in args:
    print(arg)
#add(2)
#add(2, 3, 4, 5) 둘 다 가능
``` 
- 패킹 / 언패킹
  - 패킹 <- 묶는 것
    - 여러 개의 데이터를 묶어서 변수에 할당하는 것
  - 언패킹 <- 푸는 것
    - 시퀀스 속의 요소들을 여러 개의 변수에 나누어 할당하는 것
- Asterisk(*)와 가변 인자
  - *는 스퀸스 언패킹 연산자라고도 불리며, 말 그대로 시퀀스를 풀어 헤치는 연산자 
    - 주로 튜플이나 리스트를 언패킹하는데 사용
    - *를 사용하여 가변 인자를 만들 수 있음 <- 파이썬만 갖는 독특한 방식
  - 그냥쓰면 list, 묶어주면? tuple
- 가변 키워드 인자
- 가변 인자 & 가변키워드
  - 너무 많이쓰면 다른사람이 보기에 이해하기 힘들 수 있음.
  - ex)
```python
numbers = (1, 2, 3, 4, 5) # 패킹
print(numbers) # (1, 2, 3, 4, 5)

a, b, c, d, e = numbers # 언패킹
print(a, b, c, d, e) # 1 2 3 4 5

values = [1, 2, 3, 4, 5]
print(*values) # = print(1, 2, 3, 4, 5) 별표가 없다면 ([1, 2, 3, 4, 5])가됨
#언패킹 -> 1, 2, 3, 4, 5 argument의 언패킹 *사용 cf) 패킹은 parameter

values = [1, 2, 3, 4, 5]
print(*values, sep="\n") #for문 안쓰고도 할 수 있음

'''
1
2
3
4
5
'''

def add2(*args): #parameter의 패킹 *사용, 보낼때 갯수 상관없이 여러개 입력해도 튜플 형식으로 만들어줌
    for arg in args:
        print(arg)

add2(2, 3, 4, 5)

def print_family_name(father, mother, *pets): #*pets 자리에 여러개가 입력해도 괜찮음
  print(f'아버지 : {father}')
  print(f'어머니 : {mother}'
  print('반려동물들..')
  for name in pets:
    print(f'반려동물:{name}')

print_family_name('아부지', '어무이', '멍멍이', '냥냥이')
'''
아버지 : 아부지
어머니 : 어무이
반려동물들..
반려동물: 멍멍이
반려동물: 냥냥이
'''
```
- 가변 키워드 인자(**kwargs)
  - 몇 개의 키워드 인자를 받을지 모르는 함수를 정의할 때 유용
  - **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **를 붙여 표현
  - ex)

```python
def family(**kwargs):
  for key, value in kwargs.items():
    print(key,":", value)
family(father='아부지', mother='어무이', baby='아기')
'''
father : 아부지
mother : 어무니
baby : 아기
'''

def print_family_name(father, mother, **pets):
  print("아버지 : ", father)
  print("아버지 : ", father)
  if pets:
    print("반려동물들..")
    for species, name in pets.items():
      print(f'{species} : {name}')
print_family_name('아부지', '어무이', dog='멍멍이', cat='냥냥이')
'''
아버지 : 아부지
어머니 : 어무이
반려동물들..
dog : 멍멍이
cat : 냥냥이
'''

def print_family_name(*parents, **pets):
  print("아버지 : ", parents[0])
  print("어머니 : ", parents[1])
  if pets:
    print("반려동물들..")
    for title, name in pets.items()
      print('{} : {}'.format(title, name))

print_family_name('아부지', '어무이', dog='멍멍이', cat='냥냥이')
'''
아버지 : 아부지
어머니 : 어무이
반려동물들..
dog : 멍멍이
cat : 냥냥이
'''
```

@@@@@@161
##### 함수의 범위(Scope)
 - 특정 공간, 지역, **방**
 - 함수는 코드 내부에 local scope를 생성하며, 그 외의 공간인 global scope로 구분
 - scope
   - global scope : 코드 어디에서든 참조할 수 있는 공간
   - local scope : 함수가 만든 scope. 함수 내부에서만 참조 가능
 - variable
   - global variable : global scope에 정의된 변수
   - local variable : local scope에 정의된 변수
 - 변수 수명주기(lifecyclel)
   - 변수는 각자의 수명주기(lifecyle)가 존재
     - built-in scope <- 파이썬이 존재하는 한 존재
       - 파이썬이 실행된 이후부터 영원히 유지
       - global scope <- 프로그램이 살아있는 한 존재
         - 모듈이 호출된 시점 이후 인터프리터가 끝날 때까지 유지
       - local scope
         - 함수가 호출될 때 생성되고, 함수가 종료(return)될 때까지 유지
 - 이름 검색 규칙(Name Resoultion)
   - 파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장되어 있음
   - 아래와 같은 순서로 이름을 찾아나가며, LEGB Rule이라고 부름
     - **L**ocal scope : 지역범위(현재 작업 중인 범위)
     - **E**nclosed scope : 지역 범위 한 단계 위 범위
     - **G**lobal scope : 최상단에 위치한 범위
     - **B**uilt-in-scope : 모든 것을 담고 있는 범위(정의하지 않고 사용할 수 있는 모든것 ex) print())
     - Built-in Scope <- 파이썬
       - Global scope <- 프로그램
         - Enclosed scope
           - Local scope 
             - 아래서부터 윗단계까지 하나씩 탐색을함 <- 리모컨찾기 대작전
   - 함수 내에서는 바깥 scope의 변수에 접근 가능하나 수정은 할 수 없음.
   - ex1) print(sum) #<built-in function sum> 이런식으로 검색 가능, 앞에서 sum선언해주면 선언한걸로 나옴 <- LEGB원리에 의하여
   - ex2)
    ```python
    a = 0
    b = 1
    def enclosed()
        a = 10
        c = 3
        def local(c):
            print(a, b, c) # 10 1 300 #local(300)이 들어옴으로 300이 들어감
        local(300)
        print(a, b, c) # 10 1 3
    enclosed()
    print(a, b) # 0 1 #방으로 그려서 하면 보기편함
    ```
    - global
      - parameter을 global로 쓸 수 없다
    - nonlocal
      - 글로벌은 변수를 함수 안에서 밖으로바꿀때
      - nonlocal 함수안에 함수 이럴떄 씀, 이중으로 끼워져 있을때 내 바로 위에녀석을 바꾸고 싶을 때 쓰는거
        - 만약에 바로 위에 없더라도 다음 단계가서 찾고 없으면 그 다음 단계에서 찾는 식으로 한다.
      - global과 nonlocal과 거의 같다.

 - 

##### 함수 응용
- 내장함수(Built-in Functions)
  - 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형(type)이 내장되어 있음
- map
  - map(function, iterable)
  - ex)
    ```python

    ``` 
- filter
  - filter(function, iterable)
- zip
  - zip(*iterables)
  - 세로로 묶는다!
@@@@@@@@@@@@137
- 람다(lambda) 함수
  - lambda[parameter] : 표현식
  - 특징
    - return문을 가질 수 없음
    - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
    - 일회용으로 쓸때 유용(람다도 선언하고 쓰는 것, 단지 이름이 없을뿐)
  - 장점
    - 함수를 정의해서 사용하는 것보다 간결하게 사용 가능
    - def를 사용할 수 없는 곳에서도 사용가능
- 재귀 함수(recursive function)
  - 자기 자신을 호출하는 함수
  - 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용
    - 알고리즘 중 재귀 함수로 로직을 표현하기 쉬운 경우가 있음(ex) 점화식)
    - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
  - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성
  - ex)

##### 사용자 모듈과 패키지

##### 가상환경
    - 파이썬 표준 라이브러리가 아닌 외부 패키지와 모듈을 사용하는 경우 모두 pip를 통해 설치해야함
    - 복수의 프로젝트를 하는 경우 버전이 상이할 수 있음
      - 과거 외주 프로젝트 - django 버전 2.x
      - 신규 회사 프로젝트 - django 버전 3.x
    - 가상 환경을 만들고 관리하는데 사용되는 모듈(Python 버전 3.5 부터)
    - 특정 디렉토리에 가상환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있음
      - 특정 폴더에 가상환경이(패키지 집합 폴더 등) 있고
      - 실행 환경(예 - bash)에서 가상환경을 활성화 시켜
      - 해당 폴더에 있는 패키지를 관리/사용함

### 기타tip
##### palindrome
- 면접에도 자주나옴
- 정석은 앞뒤 문자 하나하나 비교하는것임.
- [::-1]이거는 파이썬스러운 풀이법