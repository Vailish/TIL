1. 객체지향 : 확장성
2. 객체 : 역할, 책임, 협력
3. 4대 : 추상화 캡슐화 다형성 상속

- class : 설계도
- 인스턴스 : 리스트의 객체
- 객체 : 객체

### 객체
- 배틀쉽 예시
  - 역할 : 플레이어
  - 책임 : sea를 깔 책임이 있음
  - 협력 : 요청에따른 응답

### 객체지향의 핵심
- **추상화** : 불필요한 것은 걷어내고, 필요한 것만 보여주는 것 (구조(원리)는 몰라도 사용 가능한 것, ex)스마트폰) - 컴퓨터 공학을 관통하는 개념
- 캡슐화 : 객체간 간섭이 불가 why? 추상화이기 때문(**어떻게 동작을 하든 상관 없이 결과만 받으면 됨**)
  - 캡슐화때문에 객체간 간섭이 불가 == 객체에게 자율성을 부여함 -> 객체.변수로 바꾸지 않음, 인스턴스 메서드에 역할을 주었고 바깥에서 직접 바꾸지 않고 요청만함 : 그럼 그 메서드를 실행하는 건 객체의 책임
  - public
  - protected
  - private
- 다형성 : 결과만 얻으면 되기때문에 다른 객체에게 요청해도 됨(어떤 객체가 와도 상관 없다. 난 결과만 잘 받으면 된다)
- 상속 : 어떤 객체가와도 괜찮다 -> 공통점을 묶어서 줘도 된다.
- 고로, **추상화**로부터 나오는 개념들이다.

```python
a = '123'

b = list(a) # a == 생성자, list() == 클래스함수, b == list의 인스턴스
#역할 == 리스트 #책임 == 리스트를 만들고, 순서를 저장하고, 수정가능한 ... ,협동
b.append(3) # b라는 리스트의 행동(메서드)
print(b)

#파이썬은 모두 객체다 ex) list를 보더라도 mutable sequence라는 클래스를 상속받고 그 위에 contain이라는 클래스를 상속 받은 것이며, 그렇기 때문에 b는 list의 인스턴스가 된다. 따라서 추상화~상속 전부 됨.
```

클래스(추상화 하는 도구) == type(ex)list, 객체를 추상화하는 것)
- 불필요한 세부사항 없애고, 하나로 묶는다 == 이 자체가 추상화의 의미와 같음

### OOP속성
```
class
  클래스변수(클래스속성) - 클래스내 모든 객체가 같이 갖는 값
  def
    인스턴스변수 - 각각 인스턴스마다 따로 갖는 값
```

### namespace 와 function의 scope와 똑같은 개념
- 자기가 속한 구역을 먼저 탐색한 후 점차 넓은 구역으로 나가면서 탐색함.
  - 이런 원리 때문에 오버라이딩(덮어쓰기)를 하면 클래스와 인스턴스를 다르게 해줄 수 있음.

### 메서드
- 인스턴스 메서드
- 클래스 메서드
- 스태틱 메서드

##### 인스턴스 메서드
- 첫 인자는 무조건 self로 하자 : 개발자간 약속 (다른걸로 해도 되긴함)


```python
class Person
  def __init__(self, name):
    self.name = name

    def __str__(self): # 프린트 함수와 관련되 매직 메서드(str로 나와라!) 이걸 넣어주면 return값으로 출력해줌, 없을 시 object at 실제위치 로 나옴
      return self.name
    
    def __add__(self, other): # 프린트에서 + 는 어떻게 표현할 것인가
      return self.name + other.name
    
    def __del__(self):
      print('삭제되었습니다.')

person1 = Person('vailish') # 객체이자 인스턴스
person2 = Person('john')
print(person1) # vailish
print(person1 + person2) # vailishjohn
person3 = person1 # 둘은 같은 주소값
del person1 # del은 객체가 아니라 변수가 객체를 가르키는 참조를 없앤다(포스팃을 떼어낸다. == 객체는 살아있다. 연결점만 있을뿐, 삭제가 안되었기 때문에(가리키는 녀석이 하나 더 있기때문에 삭제를 바로 안함, 1개일 때는 바로 삭제함) 프린트가 먼저 출력됨, 그리고 나서 출력되는 이유는 그냥 프로그램이 끝났기 때문임.)
print(person3.name)

```
del 2개 이상 가르키는 녀석이 있는 경우 다 지워버리려면 어캐해야하나?

##### 클래스 메서드
- 모습에서는 @가 있거나 cls가 인자로 들어있거나
- 인스턴스 메서드는 클래스변수(조회만 가능), 인스턴스 변수 둘 다 사용이 가능

```python
class Person
  counts = 0
  
  def __init__(self, name, age):
    self.name = name
    self.age = age
  
  def call_name(self):
    return f'CodingGoSu. {self.name} 입니다!'

  @staticmethd #스태틱 메서드 :고정된값 불러올때 쓸거, 어떠한 인스턴스에도 클래스도 영향X (self, cls 둘 다 없음)
  def hello(): <- self 넣을 필요없음
    return '안녕하세요!'

person1 = Person('vailish', 20)
print(person1.call_name())
print(person1.hello())
```
##### 메서드 오버라이딩
- 상속 받을 거긴 한데 조금 변형을 주고 싶다 이럴때 쓰면됨
- 같은 이름으로 만들어주면 만든걸로 사용함



##### 캡슐화
__age로 접근하면 호출 불가라고는 하지만 실제로는 그 앞에 클래스이름을 넣어 이름을 작성을 한것, 즉 그 이름을 다 알게되면 똑같이 호출을 할 수는 있음.
ex) Person__age 이런식

##### getter, setter
- 정보를 직접 뜯지말고 요청 응답하는 방식으로 진행하자 (패러다임이 객체지향이니까)(함수로 만들어서)
```python
class Person:
  counts = 0

  def __init__(self, name, age):
    self.name = name
    self.__age = age
  
  def get_age(self) : #이게 getter 함수를 통해서 응답으로 값을 받음
    return self.__age

  def set_age(self, age): #setter, 함수를 통해서 수정요청, 객체에 자율성부여
    self.__age = age

  @property
  def age(self): # 여기 함수이름 age로 호출하는거임. ex) person1.age()
    return self.__age
  
  #@age.setter
  #def age(self, new_age):
  #  if new_age <= 19:
  # 대충 이런식    

person1 = Person('vailish', 25)
print(person1.get_age())

person1.set_age(30)
print(person1.get_age())

person1.age = 40 #이렇게 하면 안되지만(암묵적) 이렇게 직접적으로 바꿔주면 편하지 않을까?(내부는 그대로 동작하면서 외부적으로 이렇게 쓸 수 있게 해줌) <- property 객체 , property decoration

```

Q
* 스태틱메서드? 클래스변수?
  * 스태틱은 설계도를 지가 가지고있다? -> 이거 아닌거 같음 그 이유는 메서드는 행동이기 때문에 행동을 위해서 내놓은거지 그렇지 않은 ㅂ