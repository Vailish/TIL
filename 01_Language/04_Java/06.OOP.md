# OOP(객체지향 프로그래밍)
- 객체지향 프로그래밍
- 클래스
- JVM 메모리구조
- 생성자
- 접근제한자
- 상속

# 객체지향 프로그래밍
## 객체지향 프로그래밍
- OOP, Object Oriented Programing
- 객체 : 사물과 같이 유형적인 것과 개념이나 논리와 같은 무형적인 것들
- 지향 : 작정하거나 지정한 방향으로 나아감
- 객체 모델링 : 현실세계의 객체를 SW 객체로 설계하는 것
- ex) 사람
  - 속성 : 이름, 나이, 키, 몸무게, ...
  - 행동(기능) : 밥을 먹는다, 숨을 쉰다, ...

## 객체지향 프로그래밍 특징(`A PIE`)
- `A`bstraction (추상화)
- `P`olymorphism (다형성)
- `I`nheritance (상속)
- `E`ncapsulation (캡슐화)

# 클래스
- 관련 있는 변수와 함수를 묶어서 만든 사용자정의 <자료형>
- 모든 객체들의 생산처
- 클래스 == 객체를 생성하는 틀, `설계도`
- 프로그래밍이 쓰이는 목적을 생각하여 어떤 객체를 만들어야 하는지 결정
  - 윗줄과 아랫줄 합쳐서 `객체 모델링`
- 각 객체들이 어떤 특징(`속성`과 `동작`)을 가지고 있을지 결정
- 클래스를 통해 생성된 객체를 인스턴스라고 함
- 객체들 사이에서 메시지를 주고 받도록 만들어 줌
- 배열처럼 이름이랑 주소만 stack에 가지고 있고 정보는 heap에 담음
- 클래스 메모리(메소드 메모리)에 클래스 설계도를 가져다 씀

```java
public class Person {
    String name;
    int age;
    String hobby;

    public void info() {
        System.out.println("나의 이름은 " + name + "입니다.");
        System.out.println("나이는 "+age+"세, 취미는 "+hobby+"입니다.");
    }
}
```
## 클래스 구성
- 속성 (Atrribute) : 필드
- 동작 (Behavior) : 메소드
- 생성자 (Constructor) : 인스턴스를 생성할 때 호출 메서드
- inner class : 클래스 안에 클래스

## 클래스 선언
```
[접근제한자] [활용제한자] class 클래스명 {
    속성 정의 (필드)
    기능 정의 (메소드)
    생성자
}
```

# 변수
- 클래스 변수(class variable)
  - 클래스 영역 선언(static 키워드) ex) static int person count;
  - 생성시기 : 클래스가 메모리에 올라갔을 때
  - 모든 인스턴스가 공유함
  - 소멸 : 프로그램 종료시
- 인스턴스 변수(Instance variable)
  - 클래스 영역 선언
  - 생성시기 : 인스턴스가 생성되었을 때 (new)
  - 인스턴스 별로 생성됨
  - 소멸 -> GC
- 지역 변수(local variable)
  - 클래스 영역 이외 (메서드, 생성자 등)
  - 생성시기 : 선언되었을 때
  - 사용하기전에 초기화 필수!
  - 외부 접근 불가
  - 소멸 : 중괄호 벗어나면 소멸

# 메소드 (Method)
- 객체가 할 수 있는 행동을 정의
- 어떤 작업을 수행하는 명령문의 집합에 이름을 붙여 놓은 것
- 메소드의 이름은 소문자로 시작하는 것이 관례
```
[접근제한자] [활용제한자] 반환값 메소드이름([매개변수들]) {
    행위기술
}
ex) public static void main(String [] args){}
```
- 접근제한자 : public / protected / default / private
- 활용제한자 : static / final / abstract / synchronized
```java
public class Person {
    public void info() {
        // 메소드 내용 정의
    }
    
    public static void hello() {
        // 메소드 내용 정의
    }
}
```
- 메소드 선언 : 선언시 {}안에 메소드가 해야 할 일을 정의
- 메소드 호출
  - 호출한 메소드가 선언되어 있는 클래스를 접근
  - 클래스 객체.메소드 이름으로 호출
    - ex) Person p = new Person(); p.info();
  - static이 메소드에 선언되어 있을 때는 클래스이름.메소드 이름으로 호출
    - ex) Person.hello();

```java
public void study(int time) {
    // int time = ?
    // 파라미터는 해당 위치에 선언한 지역변수
    System.out.println(time+"시간 공부.");
}
Person p = new Person();
p.study(10);
```
- 매개변수(Parameter) : 메소드에서 사용하는 것
- 인자(Argument) : 호출하는 쪽에서 전달하는 곳
- 매개변수 생략 가능
- 파라미터 전달 시 묵시적 형 변환
  - ex) 위의 예시에서는 p.study((byte) 10); p.study((short) 10); p.study(10); 이렇게는 가능하지만
  - 더 큰 녀석인 p.study(10L); p.study(10.0f); p.study(10.0); 불가, p.study(10, 10)도 불가
```java
public int getAge() {
    return age;
}

Person p = new Person();
p.name = "Yang";
p.age = 45;
p.hobby = "유튜브";

int age = p.getAge();
```
- 리턴 타입은 메소드를 선언할 때 지정, 없다면 void (return문 생략 가능)
- 리턴 타입을 작성했다면 반드시 해당 타입의 값을 리턴
- 리턴 타입은 하나만 적용가능

```java
System.out.println()
```
- 메소드 오버로딩(Overloading)
  - 이름이 같고 매개변수가 다른 메소드를 여러 개 정의하는 것
  - 중복 코드에 대한 효율적 관리 가능
  - 파라미터의 개수 또는 순서, 타입이 달라야 할 것 (파라미터 이름만 다른것은 X)
  - 리턴 타입이 다른 것 의미X

## 클래스와 객체
- 클래스 : 관련 있는 변수와 함수를 묶어 만든 사용자 정의 자료형
- 객체 : 하나의 역할을 수행하는 '메소드와 변수(데이터)'의 묶음
- 객체지향 프로그래밍 : 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식

# JVM 메모리구조
## JVM 메모리 구조
- Java언어는 메모리 관리를 개발자가 하지 않음.
- GC(Garbage Collection)가 메모리 관리
  - Heap 영역(class 영역 포함)에 생성된 메모리 관리 담당
  - 더 이상 사용되지 않는 객체들을 점검하여 제거
  - 자동적 실행 / CPU가 한가하거나 메모리 부족일 때
  - JVM에 의해서 실행
  - System.gc()를 통해 호출(시스템에 영향 주면서 하지말자)
  - [관련 링크](https:/d2.naver.com/helloworld/1329)
![image](https://user-images.githubusercontent.com/109258380/209677501-2b57666f-9d41-431e-b3ec-fe83b4848400.png)

## 객체 생성과 메모리 할당

# Static 특징
## 로딩 시점
  - static : 클래스 로딩 시
  - non-static : 객체 생성시

## 메모리상의 차이
  - static : 클래스당 하나의 메모리 공간만 할당
  - non-static : 인스턴스 당 메모리 별도 할당
## 문법적 특징
- static : 클래스 이름으로 접근
- non-static : 객체 생성 후 접근
```java
Public class Person {
    static int pCount;

    String name;
    int age;
    String hobby;
}

Public class PersonTest {
    public static void main(String[] args) {
        Person p = new Person();
        p.name = "Kim";

        Person.pCount++;

        p.pCount++; //오류는 나지 않고 경고, 위의 방식 권장
    }
}
```
## static 영역에서 non-static 영역을 직접 접근이 불가능
```java
Public class Main {

    String str = "문장";

    public static void main(String[] args) {
        System.out.println(str); // 불가
    }
}
```

## non-static 영역에서는 static 영역에 대한 접근이 가능
```java
public class Main {
    
    static String str = "문장";

    public void print() {
        System.out.println(str);  // 가능
    }
}
```

# 생성자
## 인스턴스가 생성될 때 최초 한 번 수행되는 함수
- new 키워드와 함께 호출
- 클래스를 생성할 때 반드시 하나의 생성자 호출
- 성공적으로 실행되면 힙 영역에 객체 생성 후 객체의 번지가 리턴
- 필드의 초기화, 객체 생성 시 실행되어야 할 작업 작성
- PascalCase로 작성하는 것이 관례

## 생성자 특징
- 클래스 명과 이름이 동일(대,소문자)
- 반환타입이 없음(void 작성 x)
```java
Public class Dog {
    public Dog() {
        System.out.println("기본 생성자!");
        System.out.println("클래스 이름과 동일하고 반환 타입 X");
    }
}
```
- 기본(디폴트) 생성자
  - 클래스 내에 생성자가 하나도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자
  - 형태 : 매개변수가 없는 형태, 클래스 명() {}
  - ex) Dog d = new Dog();
- 파라미터가 있는 생성자
  - 생성자의 목적이 필드 초기화
  - 생성자 호출 시 값을 넘겨주어야 함
  - 해당 생성자를 작성하면 JVM에서 기본 생성자를 추가하지 않음
```java
class Dog {
    String name;
    int age;
}

class Main {
    public static void main(String [] a) {
        Dog d1 = new Dog();
        d1.name = "쫑";
        d1.age = 3;
    }
}

// 만약 아래와 같이 바꼇다면
class Dog(String n, int a) { // 생성자
    name = n;
    age = a;
}
// Dog d1 = new Dog(); 못 씀, 생성자 정의한 순간 기본값으로 못 만들기때문에 사용불가
// Dog d2 = new Dog("메리", 4); 와 같이 써야함
```
- 생성자 오버로딩을 지원
  - 클래스 내에 메소드 이름이 같고 매개변수의 타입 또는 개수가 다른 것
  - 이름만 바꾸는건 오버로딩아님! ex) int age -> ages 이런거
```java
class Dog {
    Dog() { }
    Dog(String name) { }
    Dog(int age) { }
    Dog(String name, int age) { }
}

class Main {
    public static void main(String [] a) {
        Dog d = new Dog();
        Dog d2 = new Dog("쫑");
        Dog d3 = new Dog(3);
        Dog d4 = new DOg('메리', 4);
    }
}
```
- this
  - 참조 변수로써 객체 자신을 가리킴(객체의 주소)
  - this를 이용하여 자신의 멤버 접근 가능
  - 지역변수와 필드의 이름이 동일할 경우 필드임을 식별할 수 있게 함
  - 객체에 대한 참조이므로 static 영역에서 this 사용 불가
- this의 활용
  - `this.멤버변수`
  - this([인자값..]) : 생성자 호출
  - this 생성자 호출 시 제한사항
    - 생성자 내에서만 호출이 가능함
    - 생성자 내에서 첫번째 구문에 위치해야 함
```java
class Dog {
    String name;
    int age;
    void info ( ) {
        System.out.print(this.name);
        System.out.println(this.age);
    }
}
```
```java
class Dog {
    String name;
    int age;
    Dog ( ) {
        this("쫑");
    }
    Dog ( String name) { //이 경우에 name에 "쫑이 들어간것과 같음"
        
    }
}
```
# 접근제한자S
# 상속